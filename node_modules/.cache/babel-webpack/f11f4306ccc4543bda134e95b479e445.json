{"ast":null,"code":"import { u } from '../localizedFormat/utils';\nvar formattingTokens = /(\\[[^[]*\\])|([-_:/.,()\\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g;\nvar match1 = /\\d/; // 0 - 9\n\nvar match2 = /\\d\\d/; // 00 - 99\n\nvar match3 = /\\d{3}/; // 000 - 999\n\nvar match4 = /\\d{4}/; // 0000 - 9999\n\nvar match1to2 = /\\d\\d?/; // 0 - 99\n\nvar matchSigned = /[+-]?\\d+/; // -inf - inf\n\nvar matchOffset = /[+-]\\d\\d:?(\\d\\d)?|Z/; // +00:00 -00:00 +0000 or -0000 +00 or Z\n\nvar matchWord = /\\d*[^-_:/,()\\s\\d]+/; // Word\n\nvar locale = {};\n\nvar parseTwoDigitYear = function parseTwoDigitYear(input) {\n  input = +input;\n  return input + (input > 68 ? 1900 : 2000);\n};\n\nfunction offsetFromString(string) {\n  if (!string) return 0;\n  if (string === 'Z') return 0;\n  var parts = string.match(/([+-]|\\d\\d)/g);\n  var minutes = +(parts[1] * 60) + (+parts[2] || 0);\n  return minutes === 0 ? 0 : parts[0] === '+' ? -minutes : minutes; // eslint-disable-line no-nested-ternary\n}\n\nvar addInput = function addInput(property) {\n  return function (input) {\n    this[property] = +input;\n  };\n};\n\nvar zoneExpressions = [matchOffset, function (input) {\n  var zone = this.zone || (this.zone = {});\n  zone.offset = offsetFromString(input);\n}];\n\nvar getLocalePart = function getLocalePart(name) {\n  var part = locale[name];\n  return part && (part.indexOf ? part : part.s.concat(part.f));\n};\n\nvar meridiemMatch = function meridiemMatch(input, isLowerCase) {\n  var isAfternoon;\n  var _locale = locale,\n      meridiem = _locale.meridiem;\n\n  if (!meridiem) {\n    isAfternoon = input === (isLowerCase ? 'pm' : 'PM');\n  } else {\n    for (var i = 1; i <= 24; i += 1) {\n      // todo: fix input === meridiem(i, 0, isLowerCase)\n      if (input.indexOf(meridiem(i, 0, isLowerCase)) > -1) {\n        isAfternoon = i > 12;\n        break;\n      }\n    }\n  }\n\n  return isAfternoon;\n};\n\nvar expressions = {\n  A: [matchWord, function (input) {\n    this.afternoon = meridiemMatch(input, false);\n  }],\n  a: [matchWord, function (input) {\n    this.afternoon = meridiemMatch(input, true);\n  }],\n  S: [match1, function (input) {\n    this.milliseconds = +input * 100;\n  }],\n  SS: [match2, function (input) {\n    this.milliseconds = +input * 10;\n  }],\n  SSS: [match3, function (input) {\n    this.milliseconds = +input;\n  }],\n  s: [match1to2, addInput('seconds')],\n  ss: [match1to2, addInput('seconds')],\n  m: [match1to2, addInput('minutes')],\n  mm: [match1to2, addInput('minutes')],\n  H: [match1to2, addInput('hours')],\n  h: [match1to2, addInput('hours')],\n  HH: [match1to2, addInput('hours')],\n  hh: [match1to2, addInput('hours')],\n  D: [match1to2, addInput('day')],\n  DD: [match2, addInput('day')],\n  Do: [matchWord, function (input) {\n    var _locale2 = locale,\n        ordinal = _locale2.ordinal;\n\n    var _input$match = input.match(/\\d+/);\n\n    this.day = _input$match[0];\n    if (!ordinal) return;\n\n    for (var i = 1; i <= 31; i += 1) {\n      if (ordinal(i).replace(/\\[|\\]/g, '') === input) {\n        this.day = i;\n      }\n    }\n  }],\n  M: [match1to2, addInput('month')],\n  MM: [match2, addInput('month')],\n  MMM: [matchWord, function (input) {\n    var months = getLocalePart('months');\n    var monthsShort = getLocalePart('monthsShort');\n    var matchIndex = (monthsShort || months.map(function (_) {\n      return _.slice(0, 3);\n    })).indexOf(input) + 1;\n\n    if (matchIndex < 1) {\n      throw new Error();\n    }\n\n    this.month = matchIndex % 12 || matchIndex;\n  }],\n  MMMM: [matchWord, function (input) {\n    var months = getLocalePart('months');\n    var matchIndex = months.indexOf(input) + 1;\n\n    if (matchIndex < 1) {\n      throw new Error();\n    }\n\n    this.month = matchIndex % 12 || matchIndex;\n  }],\n  Y: [matchSigned, addInput('year')],\n  YY: [match2, function (input) {\n    this.year = parseTwoDigitYear(input);\n  }],\n  YYYY: [match4, addInput('year')],\n  Z: zoneExpressions,\n  ZZ: zoneExpressions\n};\n\nfunction correctHours(time) {\n  var afternoon = time.afternoon;\n\n  if (afternoon !== undefined) {\n    var hours = time.hours;\n\n    if (afternoon) {\n      if (hours < 12) {\n        time.hours += 12;\n      }\n    } else if (hours === 12) {\n      time.hours = 0;\n    }\n\n    delete time.afternoon;\n  }\n}\n\nfunction makeParser(format) {\n  format = u(format, locale && locale.formats);\n  var array = format.match(formattingTokens);\n  var length = array.length;\n\n  for (var i = 0; i < length; i += 1) {\n    var token = array[i];\n    var parseTo = expressions[token];\n    var regex = parseTo && parseTo[0];\n    var parser = parseTo && parseTo[1];\n\n    if (parser) {\n      array[i] = {\n        regex: regex,\n        parser: parser\n      };\n    } else {\n      array[i] = token.replace(/^\\[|\\]$/g, '');\n    }\n  }\n\n  return function (input) {\n    var time = {};\n\n    for (var _i = 0, start = 0; _i < length; _i += 1) {\n      var _token = array[_i];\n\n      if (typeof _token === 'string') {\n        start += _token.length;\n      } else {\n        var _regex = _token.regex,\n            _parser = _token.parser;\n        var part = input.slice(start);\n\n        var match = _regex.exec(part);\n\n        var value = match[0];\n\n        _parser.call(time, value);\n\n        input = input.replace(value, '');\n      }\n    }\n\n    correctHours(time);\n    return time;\n  };\n}\n\nvar parseFormattedInput = function parseFormattedInput(input, format, utc) {\n  try {\n    if (['x', 'X'].indexOf(format) > -1) return new Date((format === 'X' ? 1000 : 1) * input);\n    var parser = makeParser(format);\n\n    var _parser2 = parser(input),\n        year = _parser2.year,\n        month = _parser2.month,\n        day = _parser2.day,\n        hours = _parser2.hours,\n        minutes = _parser2.minutes,\n        seconds = _parser2.seconds,\n        milliseconds = _parser2.milliseconds,\n        zone = _parser2.zone;\n\n    var now = new Date();\n    var d = day || (!year && !month ? now.getDate() : 1);\n    var y = year || now.getFullYear();\n    var M = 0;\n\n    if (!(year && !month)) {\n      M = month > 0 ? month - 1 : now.getMonth();\n    }\n\n    var h = hours || 0;\n    var m = minutes || 0;\n    var s = seconds || 0;\n    var ms = milliseconds || 0;\n\n    if (zone) {\n      return new Date(Date.UTC(y, M, d, h, m, s, ms + zone.offset * 60 * 1000));\n    }\n\n    if (utc) {\n      return new Date(Date.UTC(y, M, d, h, m, s, ms));\n    }\n\n    return new Date(y, M, d, h, m, s, ms);\n  } catch (e) {\n    return new Date(''); // Invalid Date\n  }\n};\n\nexport default (function (o, C, d) {\n  d.p.customParseFormat = true;\n\n  if (o && o.parseTwoDigitYear) {\n    parseTwoDigitYear = o.parseTwoDigitYear;\n  }\n\n  var proto = C.prototype;\n  var oldParse = proto.parse;\n\n  proto.parse = function (cfg) {\n    var date = cfg.date,\n        utc = cfg.utc,\n        args = cfg.args;\n    this.$u = utc;\n    var format = args[1];\n\n    if (typeof format === 'string') {\n      var isStrictWithoutLocale = args[2] === true;\n      var isStrictWithLocale = args[3] === true;\n      var isStrict = isStrictWithoutLocale || isStrictWithLocale;\n      var pl = args[2];\n\n      if (isStrictWithLocale) {\n        pl = args[2];\n      }\n\n      locale = this.$locale();\n\n      if (!isStrictWithoutLocale && pl) {\n        locale = d.Ls[pl];\n      }\n\n      this.$d = parseFormattedInput(date, format, utc);\n      this.init();\n      if (pl && pl !== true) this.$L = this.locale(pl).$L; // use != to treat\n      // input number 1410715640579 and format string '1410715640579' equal\n      // eslint-disable-next-line eqeqeq\n\n      if (isStrict && date != this.format(format)) {\n        this.$d = new Date('');\n      } // reset global locale to make parallel unit test\n\n\n      locale = {};\n    } else if (format instanceof Array) {\n      var len = format.length;\n\n      for (var i = 1; i <= len; i += 1) {\n        args[1] = format[i - 1];\n        var result = d.apply(this, args);\n\n        if (result.isValid()) {\n          this.$d = result.$d;\n          this.$L = result.$L;\n          this.init();\n          break;\n        }\n\n        if (i === len) this.$d = new Date('');\n      }\n    } else {\n      oldParse.call(this, cfg);\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"module"}